// Generated by CoffeeScript 1.6.2
(function() {
  var AppCatalogEntry, HREF_MAX_LENGTH, HREF_TEXT_MAX_LENGTH, SHORT_DESCRIPTION_MAX_LENGTH, appCatalogEntrySchema, jayschema, jp, js, jsonSchema, mongoose, t, td, uri, validator, _;

  mongoose = require('mongoose');

  jayschema = require('jayschema');

  js = new jayschema(jayschema.loaders.http);

  uri = require('uri-js');

  validator = require('validator').Validator;

  jp = require('JSONPath')["eval"];

  _ = require('underscore');

  t = function(type) {
    if (type == null) {
      type = String;
    }
    return {
      type: type
    };
  };

  td = function(type, def) {
    var val;

    if (def == null) {
      def = null;
    }
    val = t(type);
    val["default"] = def;
    return val;
  };

  appCatalogEntrySchema = mongoose.Schema({
    docVersion: td(Number, 1),
    id: t(),
    titleSection: {
      type: {
        name: t(),
        shortDescription: t(),
        pricing: t(),
        support: {
          type: {
            text: t(),
            href: t()
          }
        }
      }
    },
    descriptionSection: {
      type: {
        description: t()
      }
    },
    linksSection: {
      type: [
        {
          type: t(),
          href: t(),
          title: t()
        }
      ]
    },
    updatesSection: {
      type: {
        updates: {
          type: [Object]
        },
        qualityBands: {
          type: Object
        }
      }
    }
  });

  HREF_TEXT_MAX_LENGTH = 100;

  HREF_MAX_LENGTH = 1000;

  SHORT_DESCRIPTION_MAX_LENGTH = 140;

  jsonSchema = {
    title: 'Catalog Entry',
    type: 'object',
    "$schema": 'http://json-schema.org/draft-04/schema#',
    required: ['id', 'titleSection', 'descriptionSection', 'linksSection', 'updatesSection'],
    properties: {
      docVersion: {
        description: 'Document version number',
        type: 'number'
      },
      id: {
        description: 'The unique id for this catalog entry',
        type: 'string',
        maxLength: 100
      },
      titleSection: {
        description: 'The data for the title section',
        type: 'object',
        required: ['name', 'shortDescription', 'pricing', 'support'],
        properties: {
          name: {
            type: 'string',
            maxLength: 100
          },
          shortDescription: {
            type: 'string',
            maxLength: SHORT_DESCRIPTION_MAX_LENGTH
          },
          pricing: {
            type: 'string',
            maxLength: 50
          },
          support: {
            type: 'object',
            required: ['text', 'href'],
            properties: {
              text: {
                type: 'string',
                maxLength: HREF_TEXT_MAX_LENGTH
              },
              href: {
                type: 'string',
                maxLength: HREF_MAX_LENGTH
              }
            }
          }
        }
      },
      descriptionSection: {
        type: 'object',
        required: ['description'],
        properties: {
          description: {
            type: 'string',
            maxLength: 2000
          }
        }
      },
      linksSection: {
        type: 'array',
        items: {
          type: 'object',
          required: ['type', 'title', 'href'],
          properties: {
            'type': {
              type: 'string',
              maxLength: 50
            },
            title: {
              type: 'string',
              maxLength: HREF_TEXT_MAX_LENGTH
            },
            href: {
              type: 'string',
              maxLength: HREF_MAX_LENGTH
            }
          }
        }
      },
      updatesSection: {
        type: 'object',
        required: ['updates', 'qualityBands'],
        properties: {
          updates: {
            type: 'array',
            items: {
              type: 'object',
              required: ['date', 'description', 'version'],
              properties: {
                date: {
                  type: 'string',
                  format: 'date-time',
                  maxLength: 100
                },
                description: {
                  type: 'string',
                  maxLength: 1000
                },
                version: {
                  type: 'string',
                  maxLength: 50
                },
                releaseNotes: {
                  type: 'string',
                  maxLength: 1000
                },
                moreInfoUrl: {
                  type: 'string',
                  maxLength: HREF_MAX_LENGTH
                },
                qualityBand: {
                  type: 'string',
                  maxLength: 50
                },
                downloadUrl: {
                  type: 'string',
                  maxLength: HREF_MAX_LENGTH
                }
              }
            }
          },
          qualityBands: {
            minProperties: 1,
            patternProperties: {
              "^.*$": {
                type: 'object',
                required: ['name', 'shortDescription', 'href'],
                properties: {
                  name: {
                    type: 'string',
                    maxLength: 100
                  },
                  shortDescription: {
                    type: 'string',
                    maxLength: SHORT_DESCRIPTION_MAX_LENGTH
                  },
                  href: {
                    type: 'string',
                    maxLength: HREF_MAX_LENGTH
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  AppCatalogEntry = mongoose.model('AppCatalogEntry', appCatalogEntrySchema);

  validator.prototype.error = function(msg) {
    this._errors.push(msg);
    return this;
  };

  validator.prototype.getErrors = function() {
    return this._errors;
  };

  AppCatalogEntry.validate = function(data, callback) {
    return js.validate(data, jsonSchema, function(errs) {
      var allowableQualityBandsNames, errors, path, rogue, specifiedQualityBandNamesInUpdates, url, urls, va, validatorErrors, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

      if (errs) {
        return callback(errs);
      } else {
        errors = [];
        urls = [];
        _ref = ['href', 'downloadUrl', 'moreInfoUrl'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          urls.push.apply(urls, jp(data, '$..' + path));
        }
        for (_j = 0, _len1 = urls.length; _j < _len1; _j++) {
          url = urls[_j];
          va = new validator();
          va.check(url).isUrl();
          validatorErrors = va.getErrors();
          if (validatorErrors.length > 0) {
            errors.push({
              href: url,
              errors: validatorErrors
            });
          }
        }
        specifiedQualityBandNamesInUpdates = jp(data, '$..updates..qualityBand');
        allowableQualityBandsNames = jp(data, '$..qualityBands..name');
        _ref1 = _.difference(specifiedQualityBandNamesInUpdates, allowableQualityBandsNames);
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          rogue = _ref1[_k];
          errors.push('The qualityBand ' + rogue + ' does not exist in the updates/qualityBands section. Available bands are: ' + allowableQualityBandsNames.join(', '));
        }
        if (errors.length > 0) {
          return callback(errors);
        } else {
          return callback(null);
        }
      }
    });
  };

  module.exports = AppCatalogEntry;

}).call(this);
