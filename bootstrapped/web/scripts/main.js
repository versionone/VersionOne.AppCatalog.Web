// Generated by CoffeeScript 1.6.2
(function() {
  'RequireJS provides Asynchronous Module Definition loading, but we first must configure a few of our libraries to work with it. This includes Handlebars because it does not support AMD natively. The `shim` argument configures \nRequireJS to wrap scripts so that other modules can use them as injected, modular dependencies.\n\nFor `Video.js` and `ResponseSlives.js`, specify that they depend upon `jQuery`.';  requirejs.config({
    shim: {
      handlebars: {
        exports: 'Handlebars'
      },
      'underscore-min': {
        exports: '_'
      },
      'backbone-min': {
        deps: ['underscore-min'],
        exports: 'Backbone'
      },
      'responsiveslides': ['jquery'],
      'bootstrap.min': ['jquery'],
      video: ['jquery']
    }
  });

  define('catalogApp', [], function() {
    var catalogApp;

    catalogApp = {
      templates: {},
      associateViewWithTemplate: function(viewName, template) {
        return this[viewName].prototype.template = template;
      },
      renderView: function(viewName, data) {
        var content, val;

        if (this[viewName] != null) {
          val = new this[viewName]({
            model: data
          }).render().el;
          return val;
        } else {
          content = this.renderTemplate(viewName, data);
          return content;
        }
      },
      createTemplate: function(name, source) {
        var template;

        template = Handlebars.compile(source);
        return this.templates[name] = template;
      },
      renderTemplateSafeString: function(name, data) {
        var content;

        content = this.templates[name](data);
        return new Handlebars.SafeString(content);
      },
      renderTemplate: function(name, data) {
        var content;

        content = this.templates[name](data);
        return content;
      }
    };
    return catalogApp;
  });

  'Now, we configure this `main` module by specifing which modules it needs to operate by calling the \n`require` function and passing in an array of modules to inject. \n\nNotice that we only declare three formal arguments because those are the only ones we actually need to \nreference in our initialization function, but since event handler and other UI code requires the other \nlibraries, we ensure that they get loaded now before initialization.';

  require(['handlebars', 'jquery', 'moment', 'entryModel', 'catalogApp', 'responsiveslides', 'entryViews', 'mediaView', 'backbone-min', 'bootstrap.min'], function(Handlebars, $, moment, EntryModel, catalogApp) {
    'When all the modules are injected, we will use jQuery\'s AJAX support through `$.get` to fetch the \ndata from our Windows Azure hosted REST service. Internally, the web service pulls the data out of MongoDB, \nwhich is itself hosted via MongoLabs.\n\nBut, we do need to declare and initialize our functions first.';
    'To load external template files, we use this function, which relies on some great asynchronous convenience \nfunctions in jQuery';
    var runTemplate, templateLoader;

    templateLoader = {
      load: function(viewNames, callback) {
        var deferreds;

        deferreds = [];
        $.each(viewNames, function(index, view) {
          if (catalogApp[view]) {
            return deferreds.push($.get("tpl/" + view + ".html", function(data) {
              var template;

              template = Handlebars.compile(data);
              return catalogApp.associateViewWithTemplate(view, template);
            }, "html"));
          } else {
            console.log(view + " not found, adding to catalogApp.templates instead");
            if (!catalogApp.templates) {
              catalogApp.templates = {};
            }
            return deferreds.push($.get("tpl/" + view + ".html", function(data) {
              return catalogApp.createTemplate(view, data);
            }, "html"));
          }
        });
        return $.when.apply(null, deferreds).done(callback);
      }
    };
    catalogApp.Router = Backbone.Router.extend({
      routes: {
        "": "home",
        "entries/:id": "entryDetails"
      },
      home: function() {
        return this.entryDetails('v1clarityppm');
      },
      entryDetails: function(id) {
        var entry;

        entry = new catalogApp.EntryModel({
          id: id
        });
        return entry.fetch({
          success: function() {
            return $("#content").html(catalogApp.renderView('EntryDetailsView', entry));
          }
        });
      }
    });
    'This utility function makes calling Handlebars templates easier.';
    runTemplate = function(source, target, data) {
      var html, template;

      source = $(source).html();
      template = Handlebars.compile(source);
      html = template(data);
      return $(target).html(html);
    };
    'Register some formatting helpers for Handlebars to handle dates and the custom video tag content from our schema.';
    Handlebars.registerHelper('dateFormat', function(context, block) {
      var f;

      if (window.moment) {
        f = block.hash.format || 'MMM DD, YYYY';
        return moment(context).format(f);
      } else {
        return context;
      }
    });
    Handlebars.registerHelper('renderContent', function(content) {
      return new Handlebars.SafeString(content);
    });
    'Load the app now:';
    return templateLoader.load(['EntryDetailsView', 'TitleView', 'MediaView', 'QualifiersView', 'CallToActionView', 'EntryDetailsInfoView', 'EntryUpdatesView'], function() {
      return $(function() {
        var app;

        app = new catalogApp.Router();
        return Backbone.history.start();
      });
    });
  });

}).call(this);
